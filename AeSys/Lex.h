#pragma once
enum ETokClass { kOther, kConstant, kIdentifier, kBinaryArithmeticOp, kBinaryRelationalOp, kBinaryLogicalOp, kUnaryLogicalOp, kAssignmentOp, kOpenParenthesis, kCloseParenthesis };

struct LexColumnDefinition {
	long dataDefinition;
	long dataType;
};

struct TokenTableItem {
	int inComingPriority;
	int inStackPriority;
	ETokClass Class;
};

namespace Lex
{
	/// <LexTable> The following static table data (from LexTable.h) is a legacy from the removed command parser features. The only pieces still used are for simple expression evaluation. Lexgen can still produce this table but likely will be replaced by third party tools.
	static int g_Base[] = {
	0,
	0,
	195,
	1,
	1,
	1,
	215,
	2,
	2,
	2,
	224,
	198,
	199,
	286,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	5,
	375,
	5,
	227,
	6,
	453,
	234,
	201,
	155,
	244,
	155,
	157,
	158,
	166,
	155,
	194,
	200,
	188,
	193,
	191,
	192,
	198,
	199,
	195,
	265,
	203,
	387,
	279,
	229,
	215,
	209,
	220,
	306,
	235,
	232,
	237,
	251,
	238,
	245,
	280,
	277,
	274,
	266
	};
	static int g_Default[] = {
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	41,
	0,
	0,
	0,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	0,
	0,
	0,
	58,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13
	};
	static int g_TokenValue[] = {
	0,
	0,
	39,
	37,
	40,
	41,
	27,
	29,
	30,
	28,
	20,
	35,
	33,
	25,
	38,
	13,
	5,
	12,
	11,
	14,
	9,
	10,
	8,
	7,
	6,
	4,
	3,
	2,
	1,
	34,
	31,
	36,
	22,
	21,
	26,
	24,
	32,
	0,
	0,
	0,
	0,
	0,
	25,
	25,
	25,
	25,
	25,
	25,
	25,
	25,
	25,
	25,
	25,
	25,
	25,
	25,
	22,
	22,
	22,
	22,
	25,
	25,
	25,
	25,
	25,
	25,
	25,
	25,
	25,
	25,
	25,
	25,
	25,
	25,
	25
	};
	static int g_Next[] = {
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	2,
	37,
	0,
	0,
	0,
	3,
	0,
	4,
	5,
	6,
	7,
	0,
	8,
	38,
	9,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	0,
	0,
	11,
	39,
	12,
	0,
	0,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	0,
	0,
	0,
	0,
	0,
	0,
	60,
	13,
	61,
	13,
	62,
	13,
	13,
	13,
	63,
	13,
	13,
	42,
	13,
	13,
	13,
	13,
	13,
	72,
	64,
	65,
	13,
	13,
	13,
	13,
	13,
	13,
	0,
	14,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	36,
	34,
	32,
	31,
	29,
	37,
	30,
	56,
	32,
	20,
	48,
	15,
	18,
	16,
	33,
	17,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	33,
	33,
	33,
	33,
	33,
	33,
	33,
	33,
	33,
	33,
	59,
	59,
	59,
	59,
	59,
	59,
	59,
	59,
	59,
	59,
	19,
	21,
	22,
	23,
	24,
	28,
	25,
	26,
	27,
	41,
	32,
	58,
	58,
	58,
	58,
	58,
	58,
	58,
	58,
	58,
	58,
	40,
	40,
	41,
	51,
	52,
	69,
	50,
	49,
	40,
	43,
	57,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	70,
	71,
	46,
	45,
	47,
	55,
	54,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	53,
	68,
	67,
	73,
	13,
	0,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	32,
	0,
	44,
	0,
	0,
	56,
	0,
	0,
	0,
	0,
	66,
	0,
	59,
	74,
	33,
	33,
	33,
	33,
	33,
	33,
	33,
	33,
	33,
	33,
	59,
	0,
	58,
	58,
	58,
	58,
	58,
	58,
	58,
	58,
	58,
	58,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	40,
	40,
	0,
	0,
	0,
	0,
	0,
	0,
	40,
	0,
	57,
	37,
	37,
	35,
	37,
	37,
	37,
	37,
	37,
	37,
	37,
	37,
	37,
	37,
	37,
	37,
	37,
	37,
	37,
	37,
	37,
	37,
	37,
	37,
	37,
	37,
	37,
	37,
	37,
	37,
	37,
	37,
	37,
	37,
	37,
	37,
	37
	};
	static int g_Check[] = {
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	1,
	1,
	0,
	0,
	0,
	1,
	0,
	1,
	1,
	1,
	1,
	0,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	0,
	0,
	1,
	1,
	1,
	0,
	0,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	0,
	0,
	0,
	0,
	0,
	0,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	1,
	0,
	1,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	2,
	6,
	10,
	11,
	12,
	35,
	39,
	10,
	40,
	42,
	42,
	43,
	44,
	45,
	10,
	46,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	10,
	38,
	38,
	38,
	38,
	38,
	38,
	38,
	38,
	38,
	38,
	41,
	41,
	41,
	41,
	41,
	41,
	41,
	41,
	41,
	41,
	47,
	48,
	49,
	50,
	51,
	52,
	53,
	54,
	55,
	56,
	57,
	56,
	56,
	56,
	56,
	56,
	56,
	56,
	56,
	56,
	56,
	10,
	10,
	59,
	61,
	60,
	60,
	62,
	63,
	10,
	65,
	10,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	60,
	60,
	66,
	67,
	68,
	69,
	70,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	71,
	72,
	73,
	74,
	13,
	0,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	13,
	33,
	0,
	64,
	0,
	0,
	33,
	0,
	0,
	0,
	0,
	64,
	0,
	58,
	64,
	33,
	33,
	33,
	33,
	33,
	33,
	33,
	33,
	33,
	33,
	58,
	0,
	58,
	58,
	58,
	58,
	58,
	58,
	58,
	58,
	58,
	58,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	33,
	33,
	0,
	0,
	0,
	0,
	0,
	0,
	33,
	0,
	33,
	37,
	37,
	37,
	37,
	37,
	37,
	37,
	37,
	37,
	37,
	37,
	37,
	37,
	37,
	37,
	37,
	37,
	37,
	37,
	37,
	37,
	37,
	37,
	37,
	37,
	37,
	37,
	37,
	37,
	37,
	37,
	37,
	37,
	37,
	37,
	37
	};
	/// </LexTable> 
	/// <TokenIdentifiers> from lex_regexp.dat
	const int gc_MaximumNumberOfTokens = 128;
	const int gc_ValuesMax = 256;
	const int gc_TokenUnaryOperator = 1;
	const int gc_TokenBinaryOperator = 2;
	const int gc_TokenComparisonOperator = 4;
	const int gc_TokenLogicalOperator = 8;
	const int gc_TokenAbs = 1;
	const int gc_TokenAcos = 2;
	const int gc_TokenAsin = 3;
	const int gc_TokenAtan = 4;
	const int gc_TokenToString = 5;
	const int gc_TokenCos = 6;
	const int gc_TokenExp = 7;
	const int gc_TokenToInteger = 8;
	const int gc_TokenLn = 9;
	const int gc_TokenLog = 10;
	const int gc_TokenSin = 11;
	const int gc_TokenSqrt = 12;
	const int gc_TokenTan = 13;
	const int gc_TokenToReal = 14;
	const int gc_TokenUnaryPlus = 15;
	const int gc_TokenUnaryMinus = 16;
	const int gc_TokenInteger = 20;
	const int gc_TokenReal = 21;
	const int gc_TokenLengthOperand = 22;
	const int gc_TokenAreaOperand = 23;
	const int gc_TokenString = 24;
	const int gc_TokenIdentifier = 25;
	const int gc_TokenExponentiate = 26;
	const int gc_TokenMultiply = 27;
	const int gc_TokenDivide = 28;
	const int gc_TokenBinaryPlus = 29;
	const int gc_TokenBinaryMinus = 30;
	const int gc_TokenEq = 31;
	const int gc_TokenNe = 32;
	const int gc_TokenGt = 33;
	const int gc_TokenGe = 34;
	const int gc_TokenLt = 35;
	const int gc_TokenLe = 36;
	const int gc_TokenAnd = 37;
	const int gc_TokenOr = 38;
	const int gc_TokenNot = 39;
	const int gc_TokenLparen = 40;
	const int gc_TokenRparen = 41;
	/// </TokenIdentifiers>
	static TokenTableItem g_TokenTable[] = {
		{0, 0, kOther}, // unused
		{110, 85, kOther}, // abs
		{110, 85, kOther},	// acos
		{110, 85, kOther},	// asin
		{110, 85, kOther},	// atan
		{110, 85, kOther},	// string
		{110, 85, kOther},	// cos
		{110, 85, kOther},	// exp
		{110, 85, kOther},	// int
		{110, 85, kOther},	// ln
		{110, 85, kOther},	// log
		{110, 85, kOther},	// sin
		{110, 85, kOther},	// sqrt
		{110, 85, kOther},	// tan
		{110, 85, kOther},	// real
		{110, 85, kOther},	// unary+
		{110, 85, kOther},	// unary-
		{0, 0, kOther}, // unused
		{0, 0, kOther}, // unused
		{0, 0, kOther}, // unused
		{0, 0, kConstant}, // integer
		{0, 0, kConstant},	// real
		{0, 0, kConstant},	// length
		{0, 0, kConstant},	// area
		{0, 0, kConstant},	// string
		{0, 0, kIdentifier}, // identifier
		{80, 79, kBinaryArithmeticOp},	// **
		{70, 71, kBinaryArithmeticOp},	// *
		{70, 71, kBinaryArithmeticOp},	// /
		{60, 61, kBinaryArithmeticOp},	// +
		{60, 61, kBinaryArithmeticOp},	// -
		{40, 41, kBinaryRelationalOp},	// ==
		{40, 41, kBinaryRelationalOp}, // !=
		{40, 41, kBinaryRelationalOp}, // >
		{40, 41, kBinaryRelationalOp}, // >=
		{40, 41, kBinaryRelationalOp}, // <
		{40, 41, kBinaryRelationalOp}, // <=
		{20, 21, kBinaryLogicalOp},	// &
		{10, 11, kBinaryLogicalOp},	// |
		{30, 31, kUnaryLogicalOp}, // !
		{110, 1, kOpenParenthesis}, // (
		{0, 0, kCloseParenthesis} // )
	};
	/// <summary>
	///Converts a stream of tokens into a postfix stack for evaluation.
	/// </summary>
	/// <param name="firstTokenLocation">
	///	  (in)  location of first token in stream to consider
	///		 (out) location of first token not part of expression
	/// </param>
	/// <param name="numberOfTokens">number of tokens on stack</param>
	/// <param name="typeOfTokens">type of tokens on stack</param>
	/// <param name="locationOfTokens">location of tokens on stack</param>
	void BreakExpression(int& firstTokenLocation, int& numberOfTokens, int* typeOfTokens, int* locationOfTokens);
	
	/// <summary>Converts a literal user units string to a double precision value.</summary>
	// Notes:	Assumes that a valid literal user units string is passed with no suffix characters evaluated.
	// Effect:
	// Parameters:	valueType	type of value(s) required
	//				definition	dimension (lo word) and length (hi word) of string
	//				aszVal		string to convert
	//				alDefReq	dimension (lo word) and length (hi word) of result
	//				aVal		result
	void ConvertStringToVal(int valueType, long definition, wchar_t* szVal, long* lDefReq, void* p);

	void ConvertValToString(wchar_t*, LexColumnDefinition*, wchar_t*, int*) noexcept;
	/// <summary>Does value type conversion</summary>
	// Parameters:	valueType	type of value(s)
	//				aiTypReq	type of value(s) required
	//				definition	dimension (lo word) and length (hi word) of result
	//				apVal		value(s)
	void ConvertValTyp(int, int, long*, void*) noexcept;
	/// <summary> Evaluates an expression.</summary>
	// Returns: 1 infix expression successfully evaluated
	//			0 unspecified syntax error
	// Parameters:	aiTokId
	//				definition	dimension (lo word) and length (hi word) of result
	//				valueType		type of result
	//				apOp		result
	void EvalTokenStream(int*, long*, int*, void*);

	void Init() noexcept;
	/// <summary>Parses line into tokens.</summary>
	void Parse(const wchar_t* szLine);

	void ParseStringOperand(const wchar_t* pszTok);
	/// <summary>Scan a buffer for a given character.</summary>
	// Notes:	If the character is found the scan pointer is updated
	//			to point to the character following the one found.
	// Returns: Pointer to the character if found,	0 if not.
	LPTSTR ScanForChar(wchar_t c, wchar_t* * ppStr) noexcept;
	/// <summary>Scan for a string.</summary>
	// Notes:	The scan pointer is updated to point past the string.  The
	//			arg buffer pointer is updated to point to the next free character.
	// Returns: Pointer tot he string or 0 if an error occurs.
	wchar_t* ScanForString(wchar_t* * ppStr, wchar_t* pszTerm, wchar_t* * ppArgBuf) noexcept;

	int Scan(wchar_t* token, const wchar_t* line, int& linePosition);
	/// <summary>Skip over any white space characters.</summary>
	/// <param name="pszString">Pointer to the current buffer position.</param>
	/// <returns>Pointer to the first non-white character.</returns>
	wchar_t* SkipWhiteSpace(wchar_t* pszString) noexcept;
	/// <summary> Fetches specified tokens type from current token stream.</summary>
	// Returns:  token type
	//		 - 1 if token identifier out of range
	int TokenType(int) noexcept;

	void UnaryOp(int, int*, long*, double*);

	void UnaryOp(int, int*, long*, long*);
}
